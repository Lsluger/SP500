import numpy as np
import pandas as pd
import matplotlib.pyplot as mpl
pd.plotting.register_matplotlib_converters()


class FracDiff:

    def __init__(self, input_dataframe, num_d_values=21, get_graph=False):
        self.input_dataframe = input_dataframe
        self.num_d_values = num_d_values
        self.get_graph = get_graph
        self.optimal_d_values = self.plotMinFFD()._get_optimal_d_values()

    @staticmethod
    def getWeights(d, size):
        w = [1.]
        for k in range(1, size):
            w_ = -w[-1] / k * (d - k + 1)
            w.append(w_)
        w = np.array(w[::-1]).reshape(-1, 1)
        return w

    @staticmethod
    def plotWeights(dRange, nPlots, size):
        w = pd.DataFrame()
        for d in np.linspace(dRange[0], dRange[1], nPlots):
            w_ = FracDiff.getWeights(d, size=size)
            w_ = pd.DataFrame(w_, index=range(w_.shape[0])[::-1], columns=[d])
            w = w.join(w_, how='outer')
        ax = w.plot()
        ax.legend(loc='upper left')
        mpl.show();
        return

    @staticmethod
    def getWeights_FFD(d, thres):
        w, k = [1.], 1
        while True:
            w_ = -w[-1] / k * (d - k + 1)
            if abs(w_) < thres: break
            w.append(w_)
            k += 1
        return np.array(w[::-1]).reshape(-1, 1)

    @staticmethod
    def fracDiff_FFD(series, d, thres=1e-5):
        """Constant width window (new solution)
        Note 1: thres determines the cut-off weight for the window
        Note 2: d can be any positive fractional, not necessarily bounded [0,1]."""
        # 1) Compute weights for the longest series
        w = FracDiff.getWeights_FFD(d, thres)
        # print(w)
        width = len(w) - 1
        # 2) Apply weights to values
        df = {}
        for name in series.columns:
            seriesF, df_ = series[[name]].fillna(method='ffill').dropna(), pd.Series()
            for iloc1 in range(width, seriesF.shape[0]):
                loc0, loc1 = seriesF.index[iloc1 - width], seriesF.index[iloc1]
                if not np.isfinite(series.loc[loc1, name]): continue  # exclude NAs
                df_[loc1] = np.dot(w.T, seriesF.loc[loc0:loc1])[0, 0]
            df[name] = df_.copy(deep=True)
        df = pd.concat(df, axis=1)
        return df

    def plotMinFFD(self):
        from statsmodels.tsa.stattools import adfuller
        path, instName = './', 'ES1_Index_Method12'
        out = pd.DataFrame(columns=['adfStat', 'pVal', 'lags', 'nObs', '95% conf', 'corr'])
        try:
            df0 = pd.read_csv(path + instName + '.csv', index_col=0, parse_dates=True)
        except:
            df0 = self.input_dataframe
        for d in np.linspace(0, 1, self.num_d_values):
            df1 = np.log(df0[['Close']]).resample('1D').last()  # downcast to daily obs
            df2 = FracDiff.fracDiff_FFD(df1, d, thres=.01)
            # print(df2)
            corr = np.corrcoef(df1.loc[df2.index, 'Close'], df2['Close'])[0, 1]
            df2 = adfuller(df2['Close'], maxlag=1, regression='c', autolag=None)
            out.loc[d] = list(df2[:4]) + [df2[4]['5%']] + [corr]  # with critical value

        df_sort = out.iloc[(out['pVal'] - .05).abs().argsort()].reset_index()
        df_sort = df_sort.rename(columns={'index':'d-value'})
        df_sort = df_sort.iloc[:2, :]
        self.optimal_d_values = df_sort

        if self.get_graph:
            out.to_csv(path + instName + '_testMinFFD.csv')
            x, y1, y2 = out.index, out['corr'], out['adfStat']
            fig, ax1 = mpl.subplots()

            ax2 = ax1.twinx()
            ax1.plot(x, y1, 'g-', label='Correlation')
            ax2.plot(x, y2, 'b-', label='ADF Statistic')

            # Creates Vertical bars around optimal d value
            mpl.axvline(x=df_sort.iloc[0, 0], linewidth=2, color='c', linestyle='dashdot', label='Optimal_d Bounds')
            mpl.axvline(x=df_sort.iloc[1, 0], linewidth=2, color='c', linestyle='dashdot')
            # Creates Horizonal 95% ADF Stat
            mpl.axhline(out['95% conf'].mean(), linewidth=1, color='r', linestyle='dotted', label='Alpha=0.05')

            ax1.set_xlabel('d values', color='c')
            ax1.set_ylabel('Correlation', color='g')
            ax2.set_ylabel('ADF Statistics', color='b')
            mpl.legend(loc='upper right')

            mpl.title("Stationarity vs. Memory Preservation")
            mpl.xticks(np.arange(0, 1, step=0.1))
            mpl.savefig(path + instName + '_testMinFFD.png')

        return self

    def _get_optimal_d_values(self):
        return self.optimal_d_values

    @staticmethod
    def plot_transformed(original_df, transformed_df):
        x1, y1, x2, y2 = original_df.index, original_df['Close'], transformed_df.index, transformed_df['Close']
        fig, ax1 = mpl.subplots()
        ax2 = ax1.twinx()
        ax1.plot(x1, y1, 'b-')
        ax2.plot(x2, y2, 'g-')
        ax1.set_xlabel('Dates', color='c')
        ax1.set_ylabel('Original Price Scale', color='b')
        ax2.set_ylabel('Fractional Differenced Scale', color='g')
        mpl.title("Original Price vs. Transformed Fractional Difference")
        mpl.savefig('./'+'Orig_Transformed.png')
        return


if __name__ == "__main__":
    from pandas_datareader.data import DataReader

    df = DataReader(name='AAPL', data_source='yahoo', start='2018-01-01', end='2019-01-01')
    print(df.head())
    instance = FracDiff(df, get_graph=True)
    optimal_df = instance.optimal_d_values
    print(optimal_df)

    df1 = df[['Close']]
    df2 = FracDiff.fracDiff_FFD(df1, d=.35, thres=.01)
    print(df2.head())

    FracDiff.plot_transformed(df, df2)


